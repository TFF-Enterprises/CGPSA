#!/usr/bin/perl

# $Id$

# CommuniGate Pro SpamAssassin Filter - Version 1.0a1
# Copyright (C) 2002 TFF Enterprises
# Written by Daniel M. Zimmerman
# All Rights Reserved
#
# This CommuniGate Pro filter takes messages from CommuniGate Pro and
# checks them with SpamAssassin. It has the ability to use per-user 
# preferences, which are stored in the user's CommuniGate Pro account 
# directory, as well as to use systemwide preferences (either exclusively or
# just for those users that don't have individual preferences), and performs
# one SpamAssassin check per preferences set applicable to a given message.
#
# Scanned messages are resubmitted to CommuniGate using the PIPE module.
# Messages to non-local accounts, and to accounts for which preferences
# (individual or systemwide) are unavailable, are left untouched.
#
# Rules that invoke this filter should have the condition that "any route
# is "LOCAL*", because if no destination addresses are local the filter will 
# simply cause a delay in message processing without changing anything.
# The filter can safely be used with multiple CommuniGate Pro enqueuer 
# threads; in this case, your server must be set to allow at least as many 
# concurrent PWD connections as you have enqueuer threads.
#
# Information on user-configurable options is available in the sample 
# configuration file supplied with the filter, which must be installed as
# "<your CGP base directory>/Settings/cgp-spamassassin.conf" (unless you
# change the "CONFIG_DIRECTORY" or "CONFIG_PATHNAME" variable in 
# TFF::CGPSpamAssassin::Paths). Note that you _must_ properly set the 
# "CGP_BASE" variable (also in TFF::CGPSpamAssassin::Paths) to point to 
# your CommuniGate Pro installation in order for this filter to work 
# at all.

use strict;
use TFF::CGPSpamAssassin::Conf;
use POSIX ":sys_wait_h";
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use CGP::CLI;
use Mail::SpamAssassin;
use Mail::SpamAssassin::NoMailAudit;

# Set standard error and standard output to autoflush.

select(STDERR);
$|=1;
select(STDOUT);
$|=1;

our $conf = TFF::CGPSpamAssassin::Conf->new;

# If we don't have a configuration file, we can't do anything useful.

if ($conf->{no_configuration}) 
{
   print("* TFF Enterprises CGP SpamAssassin Filter ".VERSION.
         " - No Configuration File Found. Exiting.");
   exit();
}

# The lock file will be located in the same directory as the config file.

my $lock_pathname = 
  $conf->{cgp_base}.$conf->{config_directory}."cgp-spamassassin.lock";

# Create a SpamAssassin, using the configuration parameters we've
# read and the system defaults.

our $spamassassin = Mail::SpamAssassin->new
  ({
    dont_copy_prefs => 1,
    local_tests_only => !($conf->{do_network_tests}),
    stop_at_threshold => $conf->{stop_at_threshold},
    home_dir_for_helpers => $conf->{helper_state_dir},
    userstate_dir => $conf->{system_prefs_dir},
    debug => 0,
    paranoid => 0
   });
  
# We should set $ENV{HOME} in /tmp, to prevent creating files
# anywhere else in the system aside from our CGPro user dirs.

$ENV{'HOME'} = (-d '/tmp' ? '/tmp' : $ENV{TMP} || $ENV{TEMP})."/spamassassin-$$"; 
mkdir("$ENV{'HOME'}",0700)
  or die "fatal: Can't create $ENV{'HOME'}";
mkdir("$ENV{'HOME'}/.spamassassin", 0700)
  or die "fatal: Can't create $ENV{'HOME'}/.spamassassin";

# If we're going to use auto-whitelists, set that up.

if ($conf->{use_auto_whitelist}) 
{
  require Mail::SpamAssassin::DBBasedAddrList;

  # create a factory for the persistent address list
  my $addrlistfactory = Mail::SpamAssassin::DBBasedAddrList->new();
  $spamassassin->set_persistent_address_list_factory($addrlistfactory);
};

# Compile the SpamAssassin (without user rules) so we don't have to do
# it over and over again later.

$spamassassin->compile_now(0);
$/ = "\n";      # argh, Razor resets this!  Bad Razor! (from spamd.raw)

# Clean up the temp directories we used.

unlink <$ENV{HOME}/.spamassassin/*>,<$ENV{HOME}/*>;
rmdir "$ENV{HOME}/.spamassassin";
rmdir $ENV{HOME};
system "/bin/rm -Rf /tmp/spamassassin-$$";
delete $ENV{'HOME'};

# Clean up any old lock file that might exist.

unlink <$lock_pathname>;
 
# Set up to properly receive SIGCHLD

$SIG{CHLD} = \&REAPER;

# And, we're finally read for the Main Loop!

print("* TFF Enterprises CGP SpamAssassin Filter ".VERSION." Ready\n");

my $request = <STDIN>;
our $seqnum; # global, so it can be printed in debug lines

while ($request) 
{
  if ($request =~ /([0-9]+)\s*([A-Za-z]+)\s*(.*)/si) 
  {
    $seqnum = $1;
    my $command = $2;
    my $parameter = $3;
      
    if ($command =~ /INTF/i) 
    {
      # CGPro wants to know our interface version (it's 1). We don't
      # really care what CGPro's interface version is, since all we
      # do is DISCARD or OK messages.
      printResult("INTF 1");
    }
    elsif ($command =~ /FILE/i) 
    { 
      # CGPro is giving us a file to examine
      my $id = fork();
      if ($id == 0) 
      {
        &process_file($parameter);
      }
    }
    else 
    {
      # CGPro gave us an unknown command
      debug(1, "Unknown Command $2");
    }
  }
    
  $request = <STDIN>;
}

# And now we're done. There's no cleanup to do, so let's just exit.

lockStandardOutput();
print("* TFF Enterprises CGP SpamAssassin Filter ".VERSION." Done\n");
unlockStandardOutput();

exit();

#
# Subroutines
#

# Submit a message (parameters are a pointer to the message body,
# a return-path, and a list of envelope-to addresses) using the
# CommuniGate Pro "Submitted" directory.

sub submitMessage 
{
  my ($msg_ptr, $return_path, @addresses) = @_;
  my $filename = getUniqueFilename();
  
  open(OUTFILE, ">$filename");
  print OUTFILE "Return-Path: <".$return_path.">\n";
  foreach my $local_addr (@addresses) 
  {
    print OUTFILE "Envelope-To: <".$local_addr.">\n";
  }
  print OUTFILE @$msg_ptr;
  close(OUTFILE);
  rename($filename, $filename.".sub");
}
    
  
# Determine the "effective home directory" for SpamAssassin with respect to
# a specified user using a specified CommuniGate Pro CLI. The result depends 
# not only on whether there is a ".spamassassin/user_prefs" file in the
# user's CommuniGate Pro settings directory, but also on whether the filter 
# is set to use (and/or require) user preferences. A return value of undef 
# means that SpamAssassin should not be run for the specified user.

sub getEffectiveHomeDirectory
{
  my ($cli_ptr, $account_name) = @_;
  my $account_dir = undef;
  my $cli = ${$cli_ptr};
  
  # see if account directory exists, and if so, what it is
  if ($account_dir = $cli->GetAccountLocation($account_name)) 
  {
    if ($account_name =~ /.*@(.*)/) 
    {
      $account_dir = CGP_BASE."Domains/".$1."/".$account_dir;
    }
    else 
    {
      $account_dir = CGP_BASE."Accounts/".$account_dir;
    }
  }

  if ($conf->{use_user_prefs} && $account_dir &&
    (-e "$account_dir/.spamassassin/user_prefs"))
  {
    # $account_dir is already set to the effective home directory
  }
  elsif (!$conf->{require_user_prefs} &&
       (-e "$conf->{default_home_dir}/.spamassassin/user_prefs"))
  {
    # the default home directory is the effective home directory
    $account_dir = $conf->{default_home_dir};
  }
  else
  {
    # undef is the effective home directory
    $account_dir = undef;
  }

  return $account_dir;
}


# Check the specified message with SpamAssassin, using the specified 
# directory as the home directory for the check and the specified
# account name in the debugging output.

sub checkMessage
{
  my ($msg_ptr, $home_dir, $account_name) = @_;
  my $mail = Mail::SpamAssassin::NoMailAudit->new(data => [@$msg_ptr]);
  my $start = time;

  # Let's do SpamAssassin!
  
  $mail->replace_header($conf->{loop_prevention_header}, "Attempted");
  $mail->replace_header("X-Spam-Status", "SpamAssassin Failed");
  $spamassassin->read_scoreonly_config
    ($home_dir."/.spamassassin/user_prefs");
    
  if ($conf->{use_user_state} && $Mail::SpamAssassin::VERSION >= 2.5)
  {
    # SpamAssassin prior to 2.50 can't change user state directories
    # on the fly, unfortunately...
    
    $spamassassin->signal_user_changed 
      ({
        username => $account_name,
        user_dir => $home_dir 
       });
  }
    
  eval 
  {
    if (my $status = $spamassassin->check($mail))
    {
      $status->rewrite_mail;
  
      my $was_it_spam;
      if ($status->is_spam) 
      { 
        $was_it_spam = 'Identified spam'; 
      } 
      else 
      { 
      $was_it_spam = 'Identified non-spam'; 
      }
      my $msg_score = sprintf("%.1f", $status->get_hits);
      my $msg_threshold = sprintf("%.1f", $status->get_required_hits);
      debug(5, "$was_it_spam ($msg_score/$msg_threshold) for ".
           "$account_name in ".sprintf("%.1f", time - $start).
           " seconds");

      $status->finish();
    }
  };
  
  if ($@) 
  {
    # Something bad happened with SpamAssassin
    warn $@;
    debug(5, "SpamAssassin failed for $account_name in ".
         sprintf("%.1f", time - $start)." seconds");
  }
  
  my $rewritten_msg = join '',$mail->header,"\n",@{$mail->body};
  return $rewritten_msg;
}


# Process A CommuniGate Pro Queue File
# This subroutine _must_ be called after a fork(), because it
# exits when a result is generated.

sub process_file 
{
  my $filename = shift;
  our $seqnum;
  my $cgp_header = 1;
  my ($return_path, @local_addresses_custom, @account_dirs_custom,
    @local_addresses_default, @remote_addresses, @msglines, 
    $cgp_header);
    
  # Get a CGPInterface...
  my $cgp_interface = TFF::CGPSpamAssassin::CGPInterface->new
    ({ 
       hostname => $conf->{cgp_hostname},
       port => $conf->{cgp_port},
       login  => $conf->{cgp_username},
       password => $conf->{cgp_password}
    });
     
  if (!$cgp_interface) 
  {
    printResult("FAILURE Could not connect to CLI");
    exit();
  }
      
  chomp($filename);
  if (!$conf->{absolute_queue_filenames}) 
  {
    $filename = our CGP_BASE.$filename;
  };
  
  if (!(-e $filename))
  {
    debug(1, "Queue file $filename doesn't exist");
    printResult("OK");
    exit();
  }
  
  $cgp_header = 1;
  
  # Open the File
  
  open (MSGFILE, "$filename");
  
  # find all the destinations for the message, determine which are local
  # and remote, and which use individual or systemwide SpamAssassin 
  # preferences.
  
  foreach my $line (<MSGFILE>) 
  {
    if ($cgp_header) 
    { 
      debug(9, "Processing CGP header line: $line");
      # if we're in the headers, read an address
      if (($line =~ /^R\ W/) && ($line =~ /<(\S*)>/))
      { 
        # a recipient
        my $raw_recipient = $1;
        my $address_info = $cgp_interface->LoadAddressInfo($raw_recipient);
        
        if (!$address_info->{success})
        {
          # Failed routing, probably a bad address, add to
          # remote list.
          debug(9, "Unable to route address $raw_recipient");
          push(@remote_addresses, $raw_recipient);
        }
        else
        {          
          debug(9, "Address Info: ".
                "module ".$address_info->{module}.",".
                "host ".$address_info->{host}.",".
                "address ".$address_info->{address}.",".
                "delivery_address ".$address_info->{delivery_address});

          if ($address_info->{module} eq "LOCAL") 
          {
            # local delivery, add to appropriate local list.
 
            if ($conf->{use_advanced_prefs}             
            $account_dir = 
              getEffectiveHomeDirectory(\$cli, $data->[1]);
            debug(9, "Local address $local_address, ".
                 "account name $data->[1], ".
                 "effective home directory $account_dir");
            
            if ($address_info->{home_directory} eq
                $conf->{default_home_dir})
            {
              # use systemwide SpamAssassin prefs
              debug(8, "Using default SpamAssassin settings ".
                   "for $data->[1]");
              push(@local_addresses_default, $address_info);
            }
            elsif ($account_dir)
            {
              # use user's SpamAssassin prefs
              debug(8, "Using custom SpamAssassin settings ".
                   "for $data->[1]");
              push(@local_addresses_custom, $address_info);
            }
            else
            {
              # no SpamAssassin prefs => treat as remote
              debug(8, "No SpamAssassin settings found for ".
                   "$data->[1]");             
              push(@remote_addresses, $address_info);
            }
           } 
          elsif ($data->[0] eq "SMTP") 
          {
            # SMTP delivery, add to remote list
            push(@remote_addresses, $data->[2]);
          }
          else 
          {
            # Unknown result, add to remote list unmodified.
            debug(9, "Unsupported routing type ($data->[0]) ".
                 "for $raw_recipient");
            push(@remote_addresses, $raw_recipient);
          }
        }
        else 
        {

        }
      }
      elsif ($line =~ /^P.*<(\S*@\S*)>/) 
      {
        # the return-path
        $return_path = $1;
        debug(9, "Return-Path: $return_path");
      }
      elsif ($line =~ /^\s+$/) 
      {
        # a blank line, end of CGP headers
        debug(9, "Finished processing CGP headers");
        $cgp_header = 0;
      }
      
      next;
    }
    
    if ($line =~ /^$conf->{loop_prevention_header}.*/) 
    {
      # we've already processed this message, so let's not
      # waste time processing it again
      
      debug(5, "Previously-scanned message detected.");
      $cli->Logout();
      printResult("OK");
      exit();
    }
    
    push(@msglines, $line);
  }
  close(MSGFILE);
  
  # Now determine our course of action
  
  if (($#local_addresses_custom == -1) && 
    ($#local_addresses_default == -1))
  {
    # if there are no addresses for which SpamAssassin must be run,
    # we let the message through unaltered.
    debug(7, "No SpamAssassin run required.");
    printResult("OK");
  }
  else 
  {
    # we need to submit a bunch of new messages, so do that and
    # then DISCARD this message.
    
    # first, submit a message for all remote addresses
    
    if ($#remote_addresses >= 0) 
    {
      debug(7, "Submitting message for ".@remote_addresses.
           " addresses without SpamAssassin run");
      submitMessage(\@msglines, $return_path, @remote_addresses);
    }
    
    # then, submit a message for all local addresses using default
    # SpamAssassin prefs
    
    my $rewritten_msg;
    
    if ($#local_addresses_default >= 0)
    {
      debug(7, "Running SpamAssassin with default settings for ".
           "@local_addresses_default local addresses");
      $rewritten_msg = checkMessage(\@msglines, 
                      $conf->{default_home_dir}, 
                      "<default>");
      submitMessage([($rewritten_msg)], $return_path, 
              @local_addresses_default);
    }
    
    foreach my $local_address (@local_addresses_custom)
    {
      my $account_dir = shift(@account_dirs_custom);
      debug(7, "Running SpamAssassin with custom settings for local ".
           "address $local_address");
      $rewritten_msg = checkMessage(\@msglines, $account_dir,
                      $local_address);
      submitMessage([($rewritten_msg)], $return_path, 
              $local_address);        
    }
    
    # finally, tell the server
    printResult("DISCARD");
  }
  
  # Log out of the CommuniGate Pro CLI.
  $cli->Logout;
  
  # And since this was fork()'d, we should...
  exit();
}


# Return 1 if the passed parameter is one of the various acceptable
# ways of writing "true" (yes, on, 1, etc.), and 0 otherwise.

sub evaluateBoolean 
{
  my $boolean = shift;
  
  if (($boolean =~ /true/i) || ($boolean =~ /yes/i) ||
    ($boolean =~ /on/i) || ($boolean eq "1")) 
  {
    return 1;
  }
  else
  {
    return 0;
  }
}


# Lock standard output (using a lock file).

sub lockStandardOutput
{
  sysopen(FH, $lock_pathname, O_WRONLY | O_CREAT);
  flock(FH, LOCK_EX);
}

# Unlock standard output (using a lock file). Must be called after 
# lockStandardOutput.

sub unlockStandardOutput
{
  close(FH);
}


# Generate a unique filename

sub getUniqueFilename 
{
  my $basetime=time;
  my $rand=rand(10000);
  my $uniquename=$basetime.$rand;
  return our CGP_BASE."Submitted/".$uniquename;
}


# Output a result to standard output - this routine prepends
# the sequence number and adds a carriage return at the end.
# The parameter _must_ already be in CommuniGate Pro string
# format, unlike the parameter to debug (which can be an 
# arbitrary string). 

sub printResult
{
  my $result_string = shift;
  
  lockStandardOutput();
  print("$seqnum $result_string\n");
  unlockStandardOutput();
}


# Clean up after child processes. We really don't have to do anything
# here but wait for them to die.

sub REAPER 
{
  while (waitpid(-1,WNOHANG) > 0) {};
  $SIG{CHLD} = \&REAPER;
}

# Output a debugging string, if appropriate, to standard output. 
# It will appear in the CommuniGate Pro log, if CommuniGate Pro's
# debug level is set appropriately. It need not be in CommuniGate Pro
# string format.

sub debug 
{
  my $debug_level = scalar(shift);
  my $debug_string = shift;
  our $seqnum;
  
  if ($conf->{debug} && $debug_level <= $conf->{debug_level}) 
  {
    lockStandardOutput();
    print("* $seqnum ");
    while ($debug_string =~ /(.)/g) 
    {
      if ($1 eq "\r") 
      {
      print("\\r");
      }
      elsif ($1 eq "\n") 
      {
      print("\\n");
      }
      elsif ($1 eq "\t") 
      {
      print("\\t");
      }
      elsif ($1 eq "\\") 
      {
      print("\\\\");
      }
      elsif ($1 eq "\"") 
      {
      print("\\\"");
      }
      elsif ($1 eq "\'") 
      {
      print("\\\'");
      }
      else 
      {
      print $1;
      }
    }
    print("\n");
    unlockStandardOutput();
  }
}

# End of CommuniGate Pro SpamAssassin Filter