#!/usr/bin/perl

# $Id$

# CommuniGate Pro SpamAssassin Filter - Version 1.0a1
# Copyright (C) 2002 TFF Enterprises
# Written by Daniel M. Zimmerman
# All Rights Reserved
#
# This CommuniGate Pro filter takes messages from CommuniGate Pro
# and checks them with SpamAssassin. It performs one SpamAssassin
# operation per local user to which the message is addressed, and 
# has the ability to use per-user preferences, which are stored in
# the user's CommuniGate Pro account directory.
#
# Scanned messages are resubmitted to CommuniGate using the PIPE
# module. Messages to non-local accounts are left untouched.
#
#
# Rules that invoke this filter should have the condition that "any route
# is "LOCAL*", because if no destination addresses are local the filter will 
# simply cause a delay in message processing without changing anything.
# The filter can safely be used with multiple CommuniGate Pro enqueuer 
# threads. 
#
# Information on user-configurable options is available in the sample 
# configuration file supplied with the filter, which must be installed as
# "<your CGP base directory>/Settings/cgp-spamassassin.conf" (unless you
# change the "$config_directory" or "$config_pathname" variable below). 
# Note that you _must_ properly set the "$cgp_base" variable below for this
# filter to work at all.

#
# Customizable Variables
# Many other customizations are possible, but they are all carried out
# through the configuration file.
#

# Location of the CommuniGate Pro base directory. This is used,
# among other things, for finding the configuration file and the
# Submitted directory. It must have a trailing "/".

our $cgp_base = "/var/CommuniGate/";

# Location for the directory containing the configuration and lock files, 
# relative to the CommuniGate Pro base directory. It must have a trailing
# "/".

my $config_directory = "Settings/";

# Full paths to the configuration and lock files.

my $config_pathname = $cgp_base.$config_directory."cgp-spamassassin.conf";
my $lock_pathname = $cgp_base.$config_directory."cgp-spamassassin.lock";

#
# End of Customizable Variables
# Don't modify anything below this line unless you're absolutely
# sure you know what you're doing.
#

use strict;
use POSIX ":sys_wait_h";
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use CGP::CLI;
use Mail::SpamAssassin;
use Mail::SpamAssassin::NoMailAudit;

$|=1; # autoflush for standard output

# Version string for this filter.

our $VERSION = "1.0a1";

my %cnf;
our $conf;
$conf = \%cnf;

read_config_file($conf, $config_pathname);

# Create a SpamAssassin, using the configuration parameters we've
# read and the system defaults.

our $spamassassin = Mail::SpamAssassin->new
    ({
        dont_copy_prefs => 1,
        local_tests_only => !($conf->{do_network_tests}),
        stop_at_threshold => $conf->{stop_at_threshold},
        home_dir_for_helpers => $conf->{helper_state_dir},
        user_state_dir => $conf->{system_prefs_dir},
        debug => 0,
        paranoid => 0
     });
    
# We should set $ENV{HOME} in /tmp, to prevent creating files
# anywhere else in the system aside from our CGPro user dirs.

$ENV{'HOME'} = (-d '/tmp' ? '/tmp' : $ENV{TMP} || $ENV{TEMP})."/spamassassin-$$"; 
mkdir("$ENV{'HOME'}",0700)
    or die "fatal: Can't create $ENV{'HOME'}";
mkdir("$ENV{'HOME'}/.spamassassin", 0700)
    or die "fatal: Can't create $ENV{'HOME'}/.spamassassin";

# If we're going to use auto-whitelists, set that up.

if ($conf->{use_auto_whitelist}) 
{
    require Mail::SpamAssassin::DBBasedAddrList;

    # create a factory for the persistent address list
    my $addrlistfactory = Mail::SpamAssassin::DBBasedAddrList->new();
    $spamassassin->set_persistent_address_list_factory($addrlistfactory);
};

# Compile the SpamAssassin (without user rules) so we don't have to do
# it over and over again later.

$spamassassin->compile_now(0);
$/ = "\n";          # argh, Razor resets this!  Bad Razor! (from spamd.raw)

# Clean up the temp directories we used.

unlink <$ENV{HOME}/.spamassassin/*>,<$ENV{HOME}/*>;
rmdir "$ENV{HOME}/.spamassassin";
rmdir $ENV{HOME};
system "/bin/rm -Rf /tmp/spamassassin-$$";
delete $ENV{'HOME'};

# Clean up any old lock file that might exist.

unlink <$lock_pathname>;
 
# And, we're finally read for the Main Loop!

print("* TFF Enterprises CGP SpamAssassin Filter $VERSION Ready\n");

my $request = <STDIN>;
our $seqnum; # global, so it can be printed in debug lines

while ($request) 
{
    if ($request =~ /([0-9]+)\s*([A-Za-z]+)\s*(.*)/si) 
    {
        $seqnum = $1;
        my $command = $2;
        my $parameter = $3;
            
        if ($command =~ /INTF/i) 
        {
            # CGPro wants to know our interface version (it's 2).
            result("2");
        }
        elsif ($command =~ /FILE/i) 
        { 
            # If we have no config file, we can't do anything useful...
        
            if ($conf->{no_configuration}) 
            {
                result("FAILURE no configuration data found.");
            }
            else 
            {
                # CGPro is giving us a file to examine
                my $id = fork();
                if ($id == 0) 
                {
                    &process_file($parameter);
                }
                waitpid(-1, &WNOHANG);
                waitpid(-1, &WNOHANG);
            } 
        }
        else 
        {
            # CGPro gave us an unknown command
            debug(1, "Unknown Command $2");
        }
    }
        
    $request = <STDIN>;
}

# And now we're done. There's no cleanup to do, so let's just exit.

lock_stdout();
print("* TFF Enterprises CGP SpamAssassin Filter $VERSION Done\n");
unlock_stdout();

exit();

#
# Subroutines
#

# Output a result to standard output - this routine prepends
# the sequence number and adds a carriage return at the end.
# The parameter _must_ already be in CommuniGate Pro string
# format, unlike the parameter to debug (which can be an 
# arbitrary string). 

sub result
{
    my $result_string = shift;
    
    lock_stdout();
    print("$seqnum $result_string\n");
    unlock_stdout();
}

# Output a debugging string, if appropriate. The string need
# not be in CommuniGate Pro string format.

sub debug 
{
    my $debug_level = scalar(shift);
    my $debug_string = shift;
    our $seqnum;
    
    if ($conf->{debug} && $debug_level <= $conf->{debug_level}) 
    {
        lock_stdout();
        print("* $seqnum ");
        while ($debug_string =~ /(.)/g) 
        {
          if ($1 eq "\r") 
          {
            print("\\r");
          }
          elsif ($1 eq "\n") 
          {
            print("\\n");
          }
          elsif ($1 eq "\t") 
          {
            print("\\t");
          }
          elsif ($1 eq "\\") 
          {
            print("\\\\");
          }
          elsif ($1 eq "\"") 
          {
            print("\\\"");
          }
          elsif ($1 eq "\'") 
          {
            print("\\\'");
          }
          else 
          {
            print $1;
          }
        }
        print("\n");
        unlock_stdout();
    }
}

# Generate a unique filename

sub unique_filename 
{
    my $basetime=time;
    my $rand=rand(10000);
    my $uniquename=$basetime.$rand;
    return our $cgp_base."Submitted/".$uniquename;
}

# Submit a message (parameters are a pointer to the message body,
# a return-path, and a list of envelope-to addresses)

sub submit_message 
{
    my ($msg_ptr, $return_path, @addresses) = @_;
    my $filename = unique_filename;
    
    open(OUTFILE, ">$filename");
    print OUTFILE "Return-Path: <".$return_path.">\n";
    foreach my $local_addr (@addresses) 
    {
        print OUTFILE "Envelope-To: <".$local_addr.">\n";
    }
    print OUTFILE @$msg_ptr;
    close(OUTFILE);
    rename($filename, $filename.".sub");
}
        
    
# Submit a checked message (parameters are a pointer to the message body,
# a return-path, an envelope-to address, and a local directory path
# (to use as the SpamAssassin "home" directory, for prefs and state).
#
# If user preferences are disabled, the local directory path is not used.
# If user preferences are enabled, and the local directory path is
# undefined or there is no ".spamassassin" directory there, then either 
# the message is submitted as-is or, if system-wide preferences have been 
# defined, they are used to check the message.

sub submit_checked_message 
{
    my ($msg_ptr, $return_path, $address, $home_dir) = @_;
    my $filename = unique_filename;
    
    my $mail = Mail::SpamAssassin::NoMailAudit->new(data => [@$msg_ptr]);
    $mail->put_header($conf->{loop_prevention_header}, "Attempted");


    # Check to see if SpamAssassin prefs exist in the home dir -
    # if not, we'll either use system-wide prefs (if applicable) or
    # just pass the message on to submit_message. If no home dir is
    # specified, we treat it as no prefs existing in the home dir.
    
    my $effective_home_dir;
    
    if ($conf->{use_user_prefs} && $home_dir && 
        (-e "$home_dir/.spamassassin/user_prefs")) 
    {
        debug(8, "SpamAssassin prefs found for user $address.");
        $effective_home_dir = $home_dir;
    }
    elsif (!$conf->{require_user_prefs} &&
           (-e "$conf->{default_home_dir}/.spamassassin/user_prefs"))
    {
        debug(8, "Using systemwide SpamAssassin prefs for user $address.");
        $effective_home_dir = $conf->{default_home_dir};
    }
    else 
    {
        debug(8, "No SpamAssassin prefs available for user $address, ".
                 "submitting message unscanned.");
        $mail->replace_header
            ($conf->{loop_prevention_header}, "Not Attempted");
        my $rewritten_msg = join '',$mail->header,"\n",@{$mail->body};
        submit_message([($rewritten_msg)], $return_path, $address);
        return;
    }
        
    # It's SpamAssassin Time...

    my $start = time;

    $spamassassin->read_scoreonly_config
        ($effective_home_dir."/.spamassassin/user_prefs");
        
    if ($conf->{use_user_state} && $Mail::SpamAssassin::VERSION >= 2.5)
    {
        # SpamAssassin prior to 2.50 can't change user state directories
        # on the fly, unfortunately...
        
        $spamassassin->signal_user_changed 
            ({
                username => $address,
                user_dir => $effective_home_dir 
             });
    }
        
    my $status = $spamassassin->check($mail);
    $status->rewrite_mail;
    my $rewritten_msg = join '',$mail->header,"\n",@{$mail->body};
    submit_message([($rewritten_msg)], $return_path, $address);
    
    my $was_it_spam;
    if ($status->is_spam) 
    { 
        $was_it_spam = 'Identified spam'; 
    } 
    else 
    { 
        $was_it_spam = 'Identified non-spam'; 
    }
    my $msg_score = sprintf("%.1f",$status->get_hits);
    my $msg_threshold = sprintf("%.1f",$status->get_required_hits);
    debug(5, "$was_it_spam ($msg_score/$msg_threshold) for $address in ".
            sprintf("%.1f", time - $start)." seconds.");

    $status->finish();
}

# Process A CommuniGate Pro Queue File
# This subroutine _must_ be called after a fork(), because it
# exits when a result is generated.

sub process_file 
{
    my $filename = shift;
    our $seqnum;
    my $cgp_header = 1;
    my ($return_path, @local_addresses, @remote_addresses,
        @msglines, $cgp_header);
        
    # Log in to the CommuniGate Pro CLI
    my $cli = new CGP::CLI
        ({ PeerAddr => $conf->{cgp_hostname},
           PeerPort => $conf->{cgp_port},
           login    => $conf->{cgp_username},
           password => $conf->{cgp_password}
         });
         
    if (!$cli) 
    {
        result("FAILURE Could not connect to CLI.");
        exit();
    }
            
    chomp($filename);
    if (!$conf->{absolute_queue_filenames}) 
    {
        $filename = our $cgp_base.$filename;
    };
    
    if (!(-e $filename))
    {
        debug(1, "Queue file $filename doesn't exist.");
        result("OK");
        exit();
    }
    
    $cgp_header = 1;
    
    # Open the File
    
    open (MSGFILE, "$filename");
    foreach my $line (<MSGFILE>) 
    {
        if ($cgp_header) 
        { 
            debug(9, "Processing CGP header line: $line");
            # if we're in the headers, read an address
            if ($line =~ /^R.*<(\S*)>/) 
            {   
                # a recipient
                my $raw_recipient = $1;
                my $data=$cli->Route($1);
                debug(9, "Recipient, Result from CLI: ".
                         $data->[0].",".$data->[1].",".$data->[2]);
                if ($cli->isSuccess) 
                {
                    if ($data->[0] eq "LOCAL") 
                    {
                        # local (or system) delivery, add to local list
                        push(@local_addresses, $data->[1]);
                    } 
                    elsif ($data->[0] eq "SMTP") 
                    {
                        # SMTP delivery, add to remote list
                        push(@remote_addresses, $data->[2]);
                    }
                    else 
                    {
                        # Unknown result, add to remote list unmodified.
                        push(@remote_addresses, $raw_recipient);
                    }
                }
                else 
                {
                    # Failed routing, probably a bad address, add to
                    # local list to be submitted separately.
                    push(@local_addresses, $raw_recipient);
                }
            }
            elsif ($line =~ /^P.*<(\S*@\S*)>/) 
            {
                # the return-path
                $return_path = $1;
                debug(9, "Return-Path: $return_path");
            }
            elsif ($line =~ /^\s+$/) 
            {
                # a blank line, end of CGP headers
                $cgp_header = 0;

                debug(9, "Finished processing CGP headers.");
            }
            
            next;
        }
        
        if ($line =~ /^$conf->{loop_prevention_header}.*/) 
        {
          # we've already processed this message, so let's not
          # waste time processing it again
          
          debug(5, "Previously-scanned message detected.");
          $cli->Logout();
          result("OK");
          exit();
        }
        
        push(@msglines, $line);
    }
    close(MSGFILE);
    
    # Now determine our course of action
    
    if ($#local_addresses == -1)
    {
        # if there are no local addresses, we let the message through
        # unscathed.
        debug(7, "No local addresses found.");
        result("OK");
    }
    else 
    {
        # we need to submit a bunch of new messages, so do that and
        # then DISCARD this message.
        
        # first, submit a message for all remote addresses
        
        if ($#remote_addresses >= 0) 
        {
            debug(7, "Submitting message for ".@remote_addresses.
                     " remote addresses.");
            submit_message(\@msglines, $return_path, @remote_addresses);
        }
        
        # then, submit a message for each local address
        
        foreach my $local_addr (@local_addresses) 
        {
            my $account_dir = undef;
            
            # see if account directory exists, and if so, what it is
            if ($account_dir = $cli->GetAccountLocation($local_addr)) 
            {
                if ($local_addr =~ /.*@(.*)/) 
                {
                    $account_dir = $cgp_base."Domains/".$1.
                                   "/".$account_dir;
                }
                else 
                {
                    $account_dir = $cgp_base."Accounts/".$account_dir;
                }
            }
            
            debug(8, "Account directory for $local_addr is $account_dir.");
            debug(7, "Checking message for local address: $local_addr.");
            submit_checked_message
                (\@msglines, $return_path, $local_addr, $account_dir);
        }
        
        # finally, tell the server
        result("DISCARD");
    }
    
    # Log out of the CommuniGate Pro CLI.
    $cli->Logout;
    
    # And since this was fork()'d, we should...
    exit();
}

# Find the directory path corresponding with a user's CommuniGate
# account. The SpamAssassin data files will be stored in a
# .spamassassin folder inside that account's directory.

# Read preferences from the preferences file
sub read_config_file 
{
    my ($conf, $filename) = @_;
    
    if (!$filename || !open(IN,"<$filename")) 
    {
        # the file doesn't exist
        $conf->{no_configuration} = 1;
        return;
    }

    # default values
    
    $conf->{cgp_username} = "username";
    $conf->{cgp_password} = "password";
    $conf->{cgp_hostname} = "localhost";
    $conf->{cgp_port} = 106;
    $conf->{loop_prevention_header} = "X-TFF-SpamAssassin-Filter";
    $conf->{debug} = 0;
    $conf->{debug_level} = 0;
    $conf->{use_user_prefs} = 1;
    $conf->{require_user_prefs} = 1;
    $conf->{use_user_state} = 1;
    $conf->{use_auto_whitelist} = 1;
    $conf->{do_network_tests} = 1;
    $conf->{stop_at_threshold} = 0;
    $conf->{default_home_dir} = "/var/CommuniGate/Settings/SpamAssassin";
    $conf->{testing} = 0;
    
    my @text = (<IN>);
    close(IN);

    foreach my $line (@text) 
    {
        $line =~ s/\r//g;
        $line =~ s/(^|(?<!\\))\#.*$/$1/;
        $line =~ s/^\s+//; s/\s+$//; 
        next if ($line =~ /^$/);

        if ($line =~ /^cgp[-_]username[\s\=]+(\S+)$/) 
        {
            $conf->{cgp_username} = $1;
        }
        elsif ($line =~ /^cgp[-_]password[\s\=]+(\S+)$/) 
        {
            $conf->{cgp_password} = $1;
        }
        elsif ($line =~ /^cgp[-_]hostname[\s\=]+(\S+)$/) 
        {
            $conf->{cgp_hostname} = $1;
        }
        elsif ($line =~ /^cgp[-_]port[\s\=]+(\S+)$/) 
        {
            $conf->{cgp_port} = $1;
        }
        elsif ($line =~ /^loop[-_]prevention[-_]header[\s\=]+(\S+)$/) 
        {
            $conf->{loop_prevention_header} = $1;
        }
        elsif ($line =~ /^debug[\s\=]+(\S+)$/) 
        {
            $conf->{debug} = evaluate_boolean($1);
        }
        elsif ($line =~ /^debug[-_]level[\s\=]+([0-9])\s+$/) 
        {
            $conf->{debug_level} = scalar($1);
        }
        elsif ($line =~ /^use[-_]user[-_]prefs[\s\=]+(\S+)$/) 
        {
            $conf->{use_user_prefs} = evaluate_boolean($1);
        }
        elsif ($line =~ /^require[-_]user[-_]prefs[\s\=]+(\S+)$/) 
        {
            $conf->{require_user_prefs} = evaluate_boolean($1);
        }
        elsif ($line =~ /^use[-_]user[-_]state[\s\=]+(\S+)$/) 
        {
            $conf->{use_user_state} = evaluate_boolean($1);
        }
        elsif ($line =~ /^use[-_]auto[-_]whitelist[\s\=]+(\S+)$/) 
        {
            $conf->{use_auto_whitelist} = evaluate_boolean($1);
        }
        elsif ($line =~ /^do[-_]network[-_]tests[\s\=]+(\S+)$/) 
        {
            $conf->{do_network_tests} = evaluate_boolean($1);
        }   
        elsif ($line =~ /^stop[-_]at[-_]threshold[\s\=]+(\S+)$/) 
        {
            $conf->{stop_at_threshold} = evaluate_boolean($1);
        }
        elsif ($line =~ /^default[-_]home[-_]dir[\s\=]+(\S+)$/) 
        {
            $conf->{default_home_dir} = $1;
        }
        elsif ($line =~ /^helper[-_]state[-_]dir[\s\=]+(\S+)$/) 
        {
            $conf->{helper_state_dir} = $1;
        }
        elsif ($line =~ /^absolute[-_]queue[-_]filenames[\s\=]+(\S+)$/) 
        {
            $conf->{absolute_queue_filenames} = evaluate_boolean($1);
        }
    }
    
    # Set the home dir for helpers (this is important, so it defaults
    # to the system prefs dir).
    
    if (!$conf->{helper_state_dir})
    {
        $conf->{helper_state_dir} = $conf->{default_home_dir};
    }
}

# return 1 if the passed parameter is one of the various acceptable
# ways of writing "true" (yes, on, 1, etc.), and 0 otherwise.

sub evaluate_boolean 
{
    my $boolean = shift;
    
    if (($boolean =~ /true/i) || ($boolean =~ /yes/i) ||
        ($boolean =~ /on/i) || ($boolean eq "1")) 
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

# Lock on the lock file.

sub lock_stdout
{
    sysopen(FH, $lock_pathname, O_WRONLY | O_CREAT);
    flock(FH, LOCK_EX);
}

sub unlock_stdout
{
    close(FH);
}

