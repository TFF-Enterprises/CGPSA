#!/usr/bin/perl

# $Id$

# CGPSA - A Spam Filter for CommuniGate Pro - Version 1.2.1
# Copyright (C) 2002-2003 TFF Enterprises
# Written by Daniel M. Zimmerman
# All Rights Reserved
#
# This CommuniGate Pro filter uses SpamAssassin technology to scan messages
# being transferred by the mail server. It has two primary operating modes, 
# "full-featured" and "headers-only".
#
# In "full-featured" mode, the filter checks the recipients of each message 
# (using the CGP router, through the CGP CLI) to determine which are local 
# and which are remote, and scans messages accordingly (depending on your 
# configuration). In this mode, it has the ability to use per-user 
# preferences, which are stored in the user's CommuniGate Pro account 
# directory, as well as to use systemwide preferences (either exclusively or 
# just for those users that don't have individual preferences), and performs 
# one SpamAssassin check per preferences set applicable to a given message. 
# It can also use either per-user or systemwide state (for Razor, 
# auto-whitelists, Bayesian filtering, etc) in this mode. This mode works by 
# resubmitting messages using the CommuniGate PIPE Module.
#
# In "headers-only" mode, the filter scans all messages with the same 
# set of SpamAssassin preferences and adds headers to each message based on 
# the results of the scan; all recipients, local and remote, see exactly the 
# same added headers. This mode does not resubmit messages at all, and is 
# therefore faster, but is also much less flexible as a result.
#
# In either mode, the filter can safely be used with multiple CommuniGate 
# Pro enqueuer threads; if you have CLI usage enabled, your server must be 
# set to allow at least as many concurrent PWD connections as you have 
# enqueuer threads (preferably a couple more, for safety margin).
#
# Information on user-configurable options is available in the sample 
# configuration file supplied with the filter, which must be installed as
# "<your CGP base directory>/Settings/cgpsa.conf" (unless you
# change the "$config_directory" or "$config_pathname" variable below). 
# Note that you _must_ properly set the "$cgp_base" variable below for this
# filter to work at all.

# CGPSA requires Perl 5.6.0 or higher to run.

require 5.6.0;

#
# Customizable Variables
# Many other customizations are possible, but they are all carried out
# through the configuration file.
#

# Location of the CommuniGate Pro base directory. This is used,
# among other things, for finding the configuration file and the
# Submitted directory. It must have a trailing "/".

# Unix
our $cgp_base = "/var/CommuniGate/";

# Windows
#our $cgp_base = "c:/CommuniGate Files/";

# Location for the directory containing the configuration and lock files, 
# relative to the CommuniGate Pro base directory. It must have a trailing
# "/".

our $config_directory = "Settings/";

# Full paths to the configuration, lock, and standard error files.

our $config_pathname = $cgp_base.$config_directory."cgpsa.conf";
our $lock_pathname = $cgp_base.$config_directory."cgpsa.lock";
our $error_pathname = $cgp_base.$config_directory."cgpsa.err";

#
# End of Customizable Variables
# Don't modify anything below this line unless you're absolutely
# sure you know what you're doing.
#

use strict;
use Sys::Hostname;
use POSIX ":sys_wait_h";
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use Mail::SpamAssassin;
use Mail::SpamAssassin::NoMailAudit;
use Text::Wrap;
$SIG{'HUP'} = \&signalHUP;

# Version string for this filter.

our $VERSION = "1.2.1";

# Version information header to be added to messages (includes platform,
# perl version, hostname; primarily used for debugging)

our $VERSIONHEADERNAME = "X-TFF-CGPSA-Version";
our $VERSIONHEADERTEXT = "$VERSION (".hostname().")";

# Set standard output to autoflush.

select(STDOUT);
$|=1;

# Set up Text::Wrap

$Text::Wrap::columns = 100;
if ($Text::Wrap::VERSION >= 2001.0929)
{
  $Text::Wrap::tabstop = 4;
  $Text::Wrap::unexpand = 0;
}
  
# Clean up any old lock file that might exist.

unlink <$lock_pathname>;
 
# Print a hello.

print("* TFF Enterprises CGPSA Filter $VERSION Starting\n");

# Declare some "global" variables.

my %cnf;
our $conf = \%cnf;
our @scan_domains = undef;
our $spamassassin = undef;

# Load our preferences.

loadPreferences();

# And, we're finally read for the Main Loop!

mainLoop();

#
# Subroutines
#

# Catches the actual SIGHUP signal, and sets a flag accordingly. 

sub signalHUP
{
  our $hup_received = 1;
}

# Handles a SIGHUP, by reloading the preferences file and creating
# a new SpamAssassin. This is called by the main event loop, when a
# HUP has been detected.

sub processHUP
{
  # Give child processes a chance to be cleaned up...
  
  our %pids;
  my $pid;
  foreach $pid (keys %pids)
  {
    waitpid($pid, 0); # blocking wait
    delete $pids{$pid};
  }

  lockStandardOutput();
    
  select STDERR;
  print("* ".scalar localtime().
        " HUP Signal Received, Re-initializing CGPSA.\n");
  select STDOUT;

  if ($conf->{redirect_stderr})
  {
    # stderr is redirected, so output to stdout as well
    print("* HUP Signal Received, Re-initializing CGPSA.\n");
  }

  undef $spamassassin;
  
  loadPreferences();
  unlockStandardOutput();
  
  our $hup_received = 0;
}
 
# Loads the CGPSA preferences, and performs initialization tasks. This 
# routine assumes that it has exclusive access to standard output.
# Therefore, calls to it must occur in a context where there are
# guaranteed to be no forked processes running (i.e., startup), or 
# must be bracketed by a lock/unlockStandardOutput pair.

sub loadPreferences
{
  our($config_pathname, $conf, $VERSION);
  
  print("* Loading Configuration File ".$config_pathname."\n");
  readConfigFile($conf, $config_pathname);
  if ($conf->{no_configuration})
  {
    # Exit if there's no configuration, since we can't do anything useful.
    
    error_exit("Unable to read CGPSA configuration file, exiting.");
  }
  print("* Configuration File Loaded\n");
  
  print("* Parallel Requests Mode: ");
  if ($conf->{parallel_requests})
  {
    print("On\n");
  }
  else
  {
    print("Off\n");
  }
  
  if ($conf->{max_requests} > 0)
  {
    print("* Max Requests: $conf->{max_requests} - Be sure Auto-Restart ". 
          "is not disabled in CGP Helper Settings.\n");
  }
  
  # Redirect standard error to a file, if option is set.
  
  if ($conf->{redirect_stderr})
  {
    close(STDERR);
    open(STDERR, ">>$error_pathname");
    select(STDERR);
    $|=1;
    print("* ".scalar localtime()." Standard Error Redirected By ".
          "TFF Enterprises CGPSA Filter $VERSION\n");
    select(STDOUT);
  }
  
  # Locale change, to "C", for SpamAssassin's well-being, if option is set.
  
  if ($conf->{use_c_locale})
  {
    use POSIX qw(locale_h);
    $ENV{'LANG'} = "C";
    setlocale(LC_ALL, "C");
    $ENV{'LC_ALL'} = "C";
  }
  
  # We should set $ENV{'HOME'} to the default home directory, to prevent 
  # creating files anywhere else in the system aside from our CGPro user 
  # dirs and the default home directory. We also set $ENV{'PATH'}, to avoid 
  # problems with Perl's Taint Mode.
  
  $ENV{'HOME'} = $conf->{default_home_dir}; 
  $ENV{'PATH'} = "";
  
  if (!(-r $conf->{default_home_dir} && -w _ && -x _ && -d _))
  {
    mkdir("$ENV{'HOME'}", 0700)
      or error_exit("Can't create default home directory $ENV{'HOME'}, ".
                    "exiting.");
  }
  
  if (!(-r $conf->{default_home_dir}."/.spamassassin" && 
        -w _ && -x _ && -d _))
  {
    mkdir("$ENV{'HOME'}/.spamassassin", 0700)
      or error_exit ("Can't create directory $ENV{'HOME'}/.spamassassin, ".
                     "exiting.");
  }
  
  # Create a SpamAssassin, using the configuration parameters we've
  # read and the system defaults.
  
  our $spamassassin = Mail::SpamAssassin->new
    ({
      dont_copy_prefs => 1,
      local_tests_only => !($conf->{do_network_tests}),
      stop_at_threshold => $conf->{stop_at_threshold},
      home_dir_for_helpers => $conf->{helper_state_dir},
      user_state_dir => $conf->{default_home_dir},
      debug => 0,
      paranoid => 0
     });
    
  # If we're going to use auto-whitelists, set that up.
  
  if ($conf->{use_auto_whitelist}) 
  {
    require Mail::SpamAssassin::DBBasedAddrList;
  
    # create a factory for the persistent address list
    my $addrlistfactory = Mail::SpamAssassin::DBBasedAddrList->new();
    $spamassassin->set_persistent_address_list_factory($addrlistfactory);
  };
  
  # If we're not using user prefs, finish setting up SpamAssassin...
  
  if (!$conf->{use_user_prefs})
  {
    if (-e "$conf->{default_home_dir}/.spamassassin/user_prefs")
    {
      $spamassassin->read_scoreonly_config
        ($conf->{default_home_dir}."/.spamassassin/user_prefs");
    }
  }
  
  # Compile the SpamAssassin so we don't have to do it over and over again 
  # later. If user rules haven't been read, we'll read them as we process
  # messages...
  
  $spamassassin->compile_now(0);
  $/ = "\n";      # argh, Razor resets this!  Bad Razor! (from spamd.raw)
  
  if ($Mail::SpamAssassin::VERSION < 2.5)
  {
    error_exit("CGPSA requires SpamAssassin version 2.5 or higher ".
               "(installed SpamAssassin is version ".
               $Mail::SpamAssassin::VERSION.")");
  }
  
  print("* Using SpamAssassin Version ".Mail::SpamAssassin::Version().
        " ($Mail::SpamAssassin::SUB_VERSION)\n");
  
  print("* Default SpamAssassin Settings Location: \n");
  if (-e "$conf->{default_home_dir}/.spamassassin/user_prefs")
  {
    print("*     $conf->{default_home_dir}/.spamassassin/user_prefs\n");
  }
  else
  {
    print("*     (local.cf settings only)\n");
  }
  print("* Initialization Complete\n");
}


# The Main Loop. Repeatedly reads from stdin, and handles CGP's
# commands appropriately. This function exits when it completes.

sub mainLoop
{
  print("* TFF Enterprises CGPSA Filter $VERSION Ready\n");
  
  my $request = <STDIN>;
  my $request_count = 0;
  our $hup_received;
  our %pids;
  my $pid;
  my $cli_checked = 0;
  our $seqnum; # global, so it can be printed in debug lines
  
  while ($request) 
  {
    if ($hup_received)
    {
      # We've received a SIGHUP since our last time around; let's
      # deal with it.
      
      processHUP();
    }
    
    # Give child processes a chance to be cleaned up...
  
    foreach $pid (keys %pids)
    {
      if (waitpid($pid, &WNOHANG) < -1)
      {
        # child $pid has terminated
        delete $pids{$pid};
      }
    }
    
    if ($request =~ /([0-9]+)\s*([A-Za-z]+)\s*(.*)/si) 
    {
      $seqnum = $1;
      my $command = $2;
      my $parameter = $3;
        
      if ($command =~ /INTF/i) 
      {
        # CGPro wants to know our interface version (it's 2, because 
        # we use ADDHEADER). After we tell it so, we check for 
        # availability of the CGP CLI with respect to our 
        # configuration (assuming we haven't already). 
        printResult("INTF 2");      
        if (!$cli_checked)
        {
          checkCLI();
          $cli_checked = 1;
        }              
      }
      elsif ($command =~ /FILE/i) 
      { 
        # CGPro is giving us a file to examine
        $request_count = $request_count + 1;
        
        # Fork off a process, if we're running with parallel requests
        $pid = 0;
        if ($conf->{parallel_requests})
        {         
          # generate a random number; this compensates for the fact that
          # the new process' random number generator is just initialized
          # from this process's due to shared memory.
          rand(); 
          $pid = fork();
        }
        if ($pid == 0) 
        {
          process_file($parameter);
          if ($conf->{parallel_requests})
          {
            # We're a finished child process, so we must...
            exit();
          }
        }
        else 
        {
          $pids{$pid} = 1;
        } 
      }
      elsif ($command =~ /QUIT/i)
      {
        # CGPro wants us to quit
        lockStandardOutput();
        print("* QUIT message received, exiting.\n");
        unlockStandardOutput();
        last;
      }
      else 
      {
        # CGPro gave us an unknown command
        debug(1, "Unknown Command $2");
        printResult("OK");
      }
    }

    if (($conf->{max_requests} > 0) && 
        ($request_count >= $conf->{max_requests}))
    {
      lockStandardOutput();
      print("* Handled maximum number of requests (".
            $conf->{max_requests}."), exiting.\n");
      unlockStandardOutput();
      last;
    }
                
    $request = <STDIN>;
  }
  
  # And now we're done. We need to exit immediately.
  # We lock stdout here, just in case some children are still running...
  
  lockStandardOutput();
  print("* TFF Enterprises CGPSA Filter $VERSION Done\n");
  unlockStandardOutput();
  
  exit();
}


# Checks the version of the CommuniGate Pro CLI, to see which form
# of the Route command to use. If the CLI is not being used, this
# routine is essentially a no-op. 

sub checkCLI
{
  if ($conf->{use_cli})
  {
    eval { require CGP::CLI; };
     
    if ($@)
    {
      # CGP::CLI didn't load from CGP/CLI...
  
      eval { require CLI; };
  
      if ($@)
      {
        # OK, it's not anywhere...
        error_exit("Current CGPSA configuration requires CGP::CLI module.");
      }
      
      debug(1, "Checking for CommuniGate Pro CLI Access");
      
      my $attempts = 0;
      my $cli = undef;
      
      while (!$cli)
      {
        $cli = new CGP::CLI
          ({ PeerAddr => $conf->{cgp_hostname},
             PeerPort => $conf->{cgp_port},
             login    => $conf->{cgp_username},
             password => $conf->{cgp_password}
           });
       
         if (!$cli)
         {
           debug(1, "Could not connect to CLI (Error: ".
                    $CGP::ERR_STRING.")");
           $attempts = $attempts + 1;
           if ($attempts < 3)
           {
             debug(1, "Sleeping for 20 seconds before next attempt");
             sleep 20;
           }
           else
           {
             debug(1, "Too many failed attempts");
             error_exit("Could not connect to CLI. Exiting.");
           }
         }
      }
      
      # Check to see if the installed CommuniGate supports the "mail"
      # extension the routing CLI command.
      
      my $data=$cli->Route("postmaster MAIL");
      if ($cli->isSuccess)
      {
        # Support for the extension
        $conf->{route_mail_extension} = 1;
        debug(9, "CLI supports ROUTE ... MAIL extension");
      }
      else
      {
        # No support for the extension
        $conf->{route_mail_extension} = 0;
        debug(9, "CLI does not support ROUTE ... MAIL extension");
      }
      
      $cli->Logout();
      undef $cli;
    }
  }
}

# Submit a message (parameters are a pointer to the message body,
# a return-path, and a list of envelope-to addresses) using the
# CommuniGate Pro "Submitted" directory.

sub submitMessage 
{
  my ($msg_ptr, $return_path, @addresses) = @_;
  my $filename = our $cgp_base."Submitted/".getUniqueFilename(@addresses);
  
  open(OUTFILE, ">$filename");
  print OUTFILE "Return-Path: <".$return_path.">\n";
  foreach my $local_addr (@addresses) 
  {
    print OUTFILE "Envelope-To: <".$local_addr.">\n";
  }
  print OUTFILE @$msg_ptr;
  close(OUTFILE);
  rename($filename, $filename.".sub");
}
    
  
# Determine the "effective home directory" for SpamAssassin with respect to
# a specified user using a specified CommuniGate Pro CLI. The result depends 
# not only on whether there is a ".spamassassin/user_prefs" file in the
# user's CommuniGate Pro settings directory, but also on whether the filter 
# is set to use (and/or require) user preferences. A return value of undef 
# means that SpamAssassin should not be run for the specified user.
#
# In CGPSA 1.1 and higher, the location for user settings has been changed.
# This function will automatically move user settings detected in the old
# location to the new location, as necessary.

sub getEffectiveHomeDirectory
{
  my ($cli_ptr, $account_name) = @_;
  my $cli = ${$cli_ptr};
  my $account_dir = $cli->GetAccountLocation($account_name);
  
  # see if account directory exists, and if so, what it is
  if ($account_dir) 
  {
    if ($account_name =~ /.*@(.*)/) 
    {
      $account_dir = $cgp_base."Domains/".$1."/".$account_dir;
    }
    else 
    {
      $account_dir = $cgp_base."Accounts/".$account_dir;
    }
  }

  # check to see if old preferences directory needs to be relocated
  if ($conf->{use_user_prefs} && $account_dir)
  {
    if (-e "$account_dir/.spamassassin")
    {
      # let's grab a lock, to be sure we're the only ones renaming -
      # we'll check again to see if the directory still exists first...
      lockStandardOutput();
      if (-e "$account_dir/.spamassassin")
      {
        # the user has preferences in the old location, so let's move
        # them to the new one.
        debug(9, "Moving CGPSA 1.0.x preferences to new location.");
        if (!(-e "$account_dir/account.web"))
        {
          mkdir("$account_dir/account.web");
        }
        rename("$account_dir/.spamassassin",
               "$account_dir/account.web/.spamassassin");
      }
      unlockStandardOutput();
    }
  }
  
  # ok, now we know the prefs - if they exist - are in the right place
  # so we choose the prefs file to use
  if ($conf->{use_user_prefs} && $account_dir &&  
      (-e "$account_dir/account.web/.spamassassin/user_prefs"))
  {
    # the user has preferences, so let's use them
    $account_dir = "$account_dir/account.web";
  }
  elsif (!$conf->{require_user_prefs})
  {
    # the default home directory is the effective home directory
    $account_dir = $conf->{default_home_dir};
  }
  else
  {
    # undef is the effective home directory
    $account_dir = undef;
  }

  return $account_dir;
}

# Check the specified message with SpamAssassin, and add appropriate headers
# to it using CGP's "ADDHEADER" functionality. This is used when the "add 
# header with CGP filter mechanism" option is turned on in the preferences.

sub checkMessageAddHeader
{
  my ($msg_ptr, $unused) = @_;
  my @scanlines;
  my $msg_length = 0;
  
  # if the message is longer than 250Kcharacters, scan only the first
  # 250Kcharacters
  
  foreach my $line (@$msg_ptr)
  {
    $msg_length = $msg_length + length($line);
    if ($msg_length < 262144)
    {
      push(@scanlines, $line);
    }
    else
    {
      debug(9, "Scanning first 256K of message only");
      last;
    }
  }
  
  my $mail = Mail::SpamAssassin::NoMailAudit->new(data => [@scanlines]);
  my $start = time;
  my $newheaders = undef;
  
  # Let's do SpamAssassin! No need to read config, because we must have read
  # it already... Similarly, no need to set state directory.
  
  eval 
  {
    if (my $status = $spamassassin->check($mail))
    {
      my $was_it_spam;
      if ($status->is_spam()) 
      { 
        $was_it_spam = "Identified spam"; 
      } 
      else 
      { 
        $was_it_spam = "Identified non-spam"; 
      }
      my $msg_score = sprintf("%.1f", $status->get_hits);
      my $msg_threshold = sprintf("%.1f", $status->get_required_hits);
      debug(5, "$was_it_spam ($msg_score/$msg_threshold) in ".
               sprintf("%.1f", time - $start)." seconds");

      # Add headers. This is very similar to the way SpamAssassin actually
      # does it, and we respect all of SpamAssassin's preferences (because
      # it's a good thing to do, and prevents confusion). 
      
      # For SpamAssassin 2.5x, this is very ugly and relies on things 
      # internal to SpamAssassin
      
      my $added_sa_version_header = 0;
      
      if ($Mail::SpamAssassin::VERSION < 2.6)
      {
        if ($status->is_spam() || 
            $spamassassin->{conf}->{always_add_headers})
        {
          # Always add headers to spam, but only if requested for non-spam.
          $newheaders = "";
          if ($status->is_spam())
          {
            $newheaders .= "X-Spam-Flag: YES\e";
          }
          $newheaders .= "X-Spam-Status: ".$status->_build_status_line."\e";
          if ($spamassassin->{conf}->{spam_level_stars} == 1)
          {
            $newheaders .= "X-Spam-Level: ".
                           $spamassassin->{conf}->{spam_level_char} x 
                           int($status->{hits})."\e";
          }
        }
      
        if ($status->is_spam || $spamassassin->{conf}->{always_add_report})
        {
          # Always add report to spam, but only if requested for non-spam.
          my $spam_report = $status->get_report();
          $spam_report =~ s/^\s*\n//gm; # remove empty lines
          $spam_report =~ s/^\s*/  /gm; # each line starts with whitespace
          $spam_report =~ s/\n/\e/g;    # replace \n's with \e's 
        
          $newheaders .= "X-Spam-Report: ".$spam_report."\e";
        }
        
        # add any test-specific markup headers (for tests like Pyzor)
        foreach my $test_header_name (keys %{$status->{headers_to_add}}) 
        {
          $newheaders .= 
            $test_header_name.": ".
            $status->{headers_to_add}->{$test_header_name}."\e";
        }
      }
      else # SpamAssassin 2.60 or higher
      {
        $status->rewrite_headers();
        $newheaders = "";
        my $headerlist;
        
        if ($status->is_spam())
        {
          $headerlist = $status->{conf}->{headers_ham};
        }
        else
        {
          $headerlist = $status->{conf}->{headers_spam};
        }

        foreach my $header (keys %{$headerlist})
        {
          $newheaders .= "X-Spam-$header: ".
                         $status->{msg}->get_header("X-Spam-$header").
                         "\e";
        }
        
        if (exists $headerlist->{"Checker-Version"})
        {
          $added_sa_version_header = 1;
        }          
      }
      
      # add X-Spam-Checker-Version if it isn't there already
      if (!$added_sa_version_header)
      {
        $newheaders .= "X-Spam-Checker-Version: SpamAssassin ".
                       Mail::SpamAssassin::Version().
                       " ($Mail::SpamAssassin::SUB_VERSION)\e";
      }
      
      # always add CGPSA Version header and loop prevention header
      $newheaders .= $VERSIONHEADERNAME.": ".$VERSIONHEADERTEXT."\e";
      $newheaders .= $conf->{loop_prevention_header}.": Scanned\e";
      
      $status->finish();
      $mail->finish();
    }
  };

  if ($@) 
  {
    # Something bad happened with SpamAssassin
    
    debug(5, "SpamAssassin failed in ".sprintf("%.1f", time - $start).
             " seconds: $@");
    $newheaders = $conf->{loop_prevention_header}.": Scan Failed\e";
  }
  
  # remove any double carriage returns...
  $newheaders =~ s/\n/\e/g;   # replace \n's with \e's      
  $newheaders =~ s/\e\e/\e/g; # remove any double \e's
      
  return $newheaders;
}


# Check the specified message with SpamAssassin, using the specified 
# directory as the home directory for the check and the specified
# account name in the debugging output.

sub checkMessage
{
  my ($msg_ptr, $home_dir, $account_name) = @_;
  my @scanlines;
  my $msg_length = 0;
  
  # if the message is longer than 250Kcharacters, scan only the first
  # 250Kcharacters
  
  foreach my $line (@$msg_ptr)
  {
    $msg_length = $msg_length + length($line);
    if ($msg_length < 262144)
    {
      push(@scanlines, $line);
    }
    else
    {
      debug(9, "Scanning first 256K of message only");
      last;
    }
  }
  
  my $mail = Mail::SpamAssassin::NoMailAudit->new(data => [@scanlines]);
  my $start = time;

  # Let's do SpamAssassin!
  
  if ($conf->{use_user_prefs})
  {
    if (!$conf->{parallel_requests})
    {
      # workaround for the SpamAssassin "stacking preferences" issue
      # when parallel requests are not active
      $spamassassin->read_scoreonly_config
        (our $default_home_dir."/.spamassassin/user_prefs")
    }
    
    $spamassassin->read_scoreonly_config
      ($home_dir."/.spamassassin/user_prefs");
  }
  
  if ($conf->{use_user_state})
  {
    $spamassassin->signal_user_changed 
      ({
        username => $account_name,
        user_dir => $home_dir 
       });
  }
    
  eval 
  {
    if (my $status = $spamassassin->check($mail))
    {
      $mail->replace_original_message([@$msg_ptr]);

      # Remove any existing SpamAssassin headers from the message...
      foreach my $header_name (keys %{$mail->{headers}}) 
      {
        if ($header_name =~ /X-Spam-.*/)
        {
          $mail->delete_header($header_name);
        }
      }
    
      $status->rewrite_mail;
  
      my $was_it_spam;
      if ($status->is_spam) 
      { 
        $was_it_spam = "Identified spam"; 
      } 
      else 
      { 
        $was_it_spam = "Identified non-spam"; 
      }
      my $msg_score = sprintf("%.1f", $status->get_hits);
      my $msg_threshold = sprintf("%.1f", $status->get_required_hits);
      debug(5, "$was_it_spam ($msg_score/$msg_threshold) for ".
               "$account_name in ".sprintf("%.1f", time - $start).
               " seconds");

      $status->finish();
    }
  };
  
  if ($@) 
  {
    # Something bad happened with SpamAssassin
    
    $mail->replace_header($conf->{loop_prevention_header}, "Scan Failed");

    debug(5, "SpamAssassin failed for $account_name in ".
             sprintf("%.1f", time - $start)." seconds: $@");
  }
  else
  {
    $mail->replace_header($conf->{loop_prevention_header}, "Scanned");
  }
    
  $mail->replace_header($VERSIONHEADERNAME, $VERSIONHEADERTEXT);
  my $rewritten_msg = $mail->as_string();
  $mail->finish();
  return $rewritten_msg;
}


# Process A CommuniGate Pro Queue File
# This subroutine takes a filename and generates output appropriate
# for the CommuniGate Pro External Filter Interface.

sub process_file 
{
  my $filename = shift;
  our $seqnum;
  my ($return_path, @local_addresses_custom, @account_dirs_custom,
      @local_addresses_default, @remote_addresses, @msglines, $cgp_header,
      $all_destination);
    
  # ensure the queue file exists
  
  chomp($filename);
  if (!$conf->{absolute_queue_filenames}) 
  {
    $filename = our $cgp_base.$filename;
  };
  
  if (!(-e $filename))
  {
    debug(1, "Queue file $filename doesn't exist");
    printResult("OK");
    return;
  }
 
   # Log in to the CommuniGate Pro CLI, if necessary
  
  my $cli = undef;
  
  if ($conf->{use_cli})
  {
    $cli = new CGP::CLI
      ({ PeerAddr => $conf->{cgp_hostname},
         PeerPort => $conf->{cgp_port},
         login    => $conf->{cgp_username},
         password => $conf->{cgp_password}
       });
     
    if (!$cli) 
    {
      printResult("FAILURE");
      debug(1, "CLI Error: ".$CGP::ERR_STRING.".");
      return;
    }
  }
  
  # At this point, if $cli is undef, we know we're not using it... 
  # In any event, open the message file!
  
  open (MSGFILE, "$filename");
  
  # find all the destinations for the message, determine which are local
  # and remote, and which use individual or systemwide SpamAssassin 
  # preferences.
  
  $cgp_header = 1;
  
  # assume initially that this message is not destined for an "all@" address
  
  $all_destination = 0;
  
  foreach my $line (<MSGFILE>) 
  {
    if ($cgp_header) 
    { 
      debug(9, "Processing CGP header line: $line");
      # if we're in the headers, read an address
      if (($line =~ /^R/) && ($line =~ /<(\S*)>/) && !$all_destination)
      { 
        # a recipient
        my $raw_recipient = $1;
        
        # if we're using the CLI, go ahead and route the address to
        # figure out if it's local or not, and whether it has custom 
        # preferences or not.
        
        if ($cli)
        {
          my $data; 
          if ($conf->{route_mail_extension})
          {
            $data = $cli->Route("\"$1\" MAIL");
          }
          else
          {
            $data = $cli->Route("\"$1\"");
          }
          debug(9, "Recipient, Result from CLI: ".
                   $data->[0].",".$data->[1].",".$data->[2]);
          
          my $module = $data->[0];
          my $username = $data->[1];
          $data = undef;
          
          if ($cli->isSuccess) 
          {
            if ($module eq "LOCAL") 
            {
              # local (or system) delivery, add to appropriate
              # local list. we preserve the envelope address as much
              # as possible.
              
              my $local_address = $raw_recipient;
              
              if ($conf->{direct_mailbox_rewrite})
              {
                # if there's direct mailbox addressing, we need to 
                # replace it by account detail. we just replace the
                # first "#" in the address by "+"; this is safe,
                # because anything after the "+" is considered
                # part of the account detail.
                
                $local_address =~ s/#/\+/;
                debug(8, "Rewrote DMA as account detail: $local_address");
              }
              
              if ($username =~ /\*@(\S*)/)
              {
                # this is an "all@" message, so we need to process it with
                # ADDHEADER for security reasons (since PIPE is a trusted
                # source - silly CGP)
                
                debug(8, "all@ recipient address detected, using ".
                         "ADDHEADER mode for all recipients");
                $all_destination = 1;
              }
              elsif (($raw_recipient =~ /(\S*)#(\S*)/) &&
                      !$conf->{direct_mailbox_scan})
              {
                # there's DMA, so this is a "remote" address
                debug(8, "Using direct mailbox addressing for ".
                         $local_address. " (no scan)");
                push(@remote_addresses, $local_address);
              }
              else
              {
                # we have to attempt a scan
                my $account_dir = 
                  getEffectiveHomeDirectory(\$cli, $username);
                debug(9, "Local address ".$local_address.", account name ".
                         $username.", effective home directory ".
                         $account_dir);
                
                if ($account_dir eq $conf->{default_home_dir})
                {
                  # use systemwide SpamAssassin prefs
                  debug(8, "Using default SpamAssassin settings for ".
                           $username); 
                  push(@local_addresses_default, $local_address);
                }
                elsif ($account_dir)
                {
                  # use user's SpamAssassin prefs
                  debug(8, "Using custom SpamAssassin settings for ".
                           $username);
                  push(@local_addresses_custom, $local_address);
                  push(@account_dirs_custom, $account_dir);
                }
                else
                {
                  # no SpamAssassin prefs => treat as remote
                  debug(8, "No SpamAssassin settings found for ".$username);
                  push(@remote_addresses, $local_address);
                }
              }
            }
            elsif (our @scan_domains)
            {
              # check to see if the destination is in one of our scan
              # domains. if so, add it to the default local list.

              my $matched = 0;

              foreach my $domain (@scan_domains)
              {
                if ($username eq $domain)
                {
                  debug(8, "Using default SpamAssassin settings for ".
                           "remote address ".$raw_recipient.
                           " (in scan domain $domain)");
                  push(@local_addresses_default, $raw_recipient);
                  $matched = 1;
                  last;
                }
              }

              if (!$matched)
              {
                # we didn't match any of the special domains, so let's
                # treat the recipient as remote

                push(@remote_addresses, $raw_recipient);
              }
            } 
            else 
            {
              # add the address to the remote list
              push(@remote_addresses, $raw_recipient);
            }
          }
          else 
          {
            # Failed routing, probably a bad address, add to remote list.
            debug(9, "Unable to route address ".$raw_recipient);
            push(@remote_addresses, $raw_recipient);
          }
        }
        else 
        {
          # no CLI, so...
          debug(8, "Using default SpamAssassin settings for ".
                   $raw_recipient);
          push(@local_addresses_default, $raw_recipient);
        }
      }
      elsif ($line =~ /^P.*<(\S*@\S*)>/ && !$all_destination) 
      {
        # the return-path
        $return_path = $1;
        debug(9, "Return-Path: $return_path");
      }
      elsif ($line =~ /^\s+$/) 
      {
        # a blank line, end of CGP headers
        debug(9, "Finished processing CGP headers");
        $cgp_header = 0;
      }
      
      next;
    }
    
    if ($line =~ /^$conf->{loop_prevention_header}.*/) 
    {
      # we've already processed this message, so let's not
      # waste time processing it again - be sure to clean up
      # by closing thre CLI and the queue file
      
      debug(5, "Previously-scanned message detected");
      if ($cli)
      {
        $cli->Logout();
        undef $cli;
      }
      close(MSGFILE);
      printResult("OK");
      return;
    }
    
    push(@msglines, $line);
  }

  # close the CLI, if necessary, and the queue file
  
  if ($cli)
  {
    $cli->Logout();
    undef $cli;
  }
  close(MSGFILE);
  
  # Now determine our course of action
  
  if ($conf->{headers_only} || $all_destination)
  {
    # we're in "headers-only" mode, so we always run SA
    debug(7, "Running SpamAssassin in ADDHEADER mode");
    my $newheaders = checkMessageAddHeader(\@msglines, "");
    printResult("ADDHEADER", $newheaders);
  }
  elsif (($#local_addresses_custom == -1) && 
         ($#local_addresses_default == -1))
  {
    # if there are no addresses for which SpamAssassin must be run,
    # we let the message through unaltered.
    debug(7, "No SpamAssassin run required");
    printResult("OK");
  }
  else
  {
    # we need to submit a bunch of new messages, so do that and
    # then DISCARD this message.
    
    # first, submit a message for all remote addresses
    
    if ($#remote_addresses >= 0) 
    {
      debug(7, "Submitting message for ".scalar(@remote_addresses).
               " addresses without SpamAssassin run");
      submitMessage(\@msglines, $return_path, @remote_addresses);
    }
    
    # then, submit a message for all local addresses using default
    # SpamAssassin prefs
    
    my $rewritten_msg;
    
    if ($#local_addresses_default >= 0)
    {
      my $plural = "";
      if ($#local_addresses_default > 1)
      {
        $plural = "es";
      }
      
      debug(7, "Running SpamAssassin with default settings for ".
               scalar(@local_addresses_default)." address".$plural);
      $rewritten_msg = 
        checkMessage(\@msglines, $conf->{default_home_dir}, "<default>");
      submitMessage([($rewritten_msg)], $return_path, 
                    @local_addresses_default);
    }
    
    foreach my $local_address (@local_addresses_custom)
    {
      my $account_dir = shift(@account_dirs_custom);
      debug(7, "Running SpamAssassin with settings from ".
               $account_dir."/.spamassassin/user_prefs ".
               "for local address ".$local_address);
      $rewritten_msg = 
        checkMessage(\@msglines, $account_dir, $local_address);
      submitMessage([($rewritten_msg)], $return_path, $local_address);        
    }
    
    # finally, tell the server
    printResult("DISCARD");
  }
}


# Read preferences from the preferences file.

sub readConfigFile 
{
  my ($conf, $filename) = @_;
  our @scan_domains;
  
  if (!$filename || !open(IN,"<$filename")) 
  {
    # the file doesn't exist
    $conf->{no_configuration} = 1;
    return;
  }

  # default values
  
  $conf->{cgp_username} = "username";
  $conf->{cgp_password} = "password";
  $conf->{cgp_hostname} = "localhost";
  # parallel_requests defaults to on if we're not on Windows
  if ($^O =~ /^(?:mswin|dos|os2)/oi)
  {
    $conf->{parallel_requests} = 0;
  }
  else
  {
    $conf->{parallel_requests} = 1;
  }
  $conf->{max_requests} = 0;
  $conf->{headers_only} = 0;
  $conf->{use_cli} = 1;
  $conf->{cgp_port} = 106;
  $conf->{loop_prevention_header} = "X-TFF-CGPSA-Filter";
  $conf->{scan_domains} = 0;
  undef @scan_domains;
  $conf->{direct_mailbox_scan} = 0;
  $conf->{direct_mailbox_rewrite} = 0;
  $conf->{debug} = 1;
  $conf->{debug_level} = 9;
  $conf->{default_home_dir} = $cgp_base.$config_directory."SpamAssassin";
  $conf->{use_user_prefs} = 0;
  $conf->{require_user_prefs} = 0;
  $conf->{use_user_state} = 0;
  $conf->{use_auto_whitelist} = 1;
  $conf->{do_network_tests} = 1;
  $conf->{stop_at_threshold} = 0;
  $conf->{use_c_locale} = 1;
  $conf->{redirect_stderr} = 1;
  $conf->{absolute_queue_filenames} = 0;
 #$conf->{route_mail_extension} set at runtime initialization
 
  my @text = (<IN>);
  close(IN);

  foreach my $line (@text) 
  {
    $line =~ s/\r//g;
    $line =~ s/(^|(?<!\\))\#.*$/$1/;
    $line =~ s/^\s+//; s/\s+$//; 
    next if ($line =~ /^$/);

    if ($line =~ /^cgp[-_]username[\s\=]+(\S+)$/) 
    {
      $conf->{cgp_username} = $1;
    }
    elsif ($line =~ /^cgp[-_]password[\s\=]+(\S+)$/) 
    {
      $conf->{cgp_password} = $1;
    }
    elsif ($line =~ /^cgp[-_]hostname[\s\=]+(\S+)$/)
    {
      $conf->{cgp_hostname} = $1;
    }
    elsif ($line =~ /^parallel[-_]requests[\s\=]+(\S+)$/)
    {
      $conf->{parallel_requests} = evaluateBoolean($1);
    }
    elsif ($line =~ /^max[-_]requests[\s\=]+([0-9]+)\s+$/) 
    {
      $conf->{max_requests} = scalar($1);
      if ($conf->{max_requests} < 0)
      {
        $conf->{max_requests} = 0;
      }
    }
    elsif ($line =~ /^headers[-_]only[\s\=]+(\S+)$/)
    {
      $conf->{headers_only} = evaluateBoolean($1);
    }
    elsif ($line =~ /^use[-_]cli[\s\=]+(\S+)$/)
    {
      $conf->{use_cli} = evaluateBoolean($1);
    }
    elsif ($line =~ /^cgp[-_]port[\s\=]+(\S+)$/) 
    {
      $conf->{cgp_port} = $1;
    }
    elsif ($line =~ /^loop[-_]prevention[-_]header[\s\=]+(\S+)$/) 
    {
      $conf->{loop_prevention_header} = $1;
    }
    elsif ($line =~ /^scan[-_]domains[\s\=]+(.+)$/)
    {
      # got to parse a space-separated list of domain names
      @scan_domains = split /\s+/, $1;
      $conf->{scan_domains} = 1;
    }
    elsif ($line =~ /^direct[-_]mailbox[-_]scan[\s\=]+(\S+)$/) 
    {
      $conf->{direct_mailbox_scan} = evaluateBoolean($1);
    }
    elsif ($line =~ /^direct[-_]mailbox[-_]rewrite[\s\=]+(\S+)$/)
    {
      $conf->{direct_mailbox_rewrite} = evaluateBoolean($1);
    }
    elsif ($line =~ /^debug[\s\=]+(\S+)$/) 
    {
      $conf->{debug} = evaluateBoolean($1);
    }
    elsif ($line =~ /^debug[-_]level[\s\=]+([0-9])\s+$/) 
    {
      $conf->{debug_level} = scalar($1);
    }
    elsif ($line =~ /^default[-_]home[-_]dir[\s\=]+(\S+)$/) 
    {
      $conf->{default_home_dir} = $1;
    }
    elsif ($line =~ /^use[-_]user[-_]prefs[\s\=]+(\S+)$/) 
    {
      $conf->{use_user_prefs} = evaluateBoolean($1);
    }
    elsif ($line =~ /^require[-_]user[-_]prefs[\s\=]+(\S+)$/) 
    {
      $conf->{require_user_prefs} = evaluateBoolean($1);
    }
    elsif ($line =~ /^use[-_]user[-_]state[\s\=]+(\S+)$/) 
    {
      $conf->{use_user_state} = evaluateBoolean($1);
    }
    elsif ($line =~ /^use[-_]auto[-_]whitelist[\s\=]+(\S+)$/) 
    {
      $conf->{use_auto_whitelist} = evaluateBoolean($1);
    }
    elsif ($line =~ /^do[-_]network[-_]tests[\s\=]+(\S+)$/) 
    {
      $conf->{do_network_tests} = evaluateBoolean($1);
    } 
    elsif ($line =~ /^stop[-_]at[-_]threshold[\s\=]+(\S+)$/) 
    {
      $conf->{stop_at_threshold} = evaluateBoolean($1);
    }
    elsif ($line =~ /^helper[-_]state[-_]dir[\s\=]+(\S+)$/) 
    {
      $conf->{helper_state_dir} = $1;
    }
    elsif ($line =~ /^use[-_]c[-_]locale[\s\=]+(\S+)$/)
    {
      $conf->{use_c_locale} = evaluateBoolean($1);
    }
    elsif ($line =~ /^redirect[-_]stderr[\s\=]+(\S+)$/)
    {
      $conf->{redirect_stderr} = evaluateBoolean($1);
    }
    elsif ($line =~ /^absolute[-_]queue[-_]filenames[\s\=]+(\S+)$/) 
    {
      $conf->{absolute_queue_filenames} = evaluateBoolean($1);
    }
  }
  
  # Set the home dir for helpers (this is important, so it defaults
  # to the system prefs dir).
  
  if (!$conf->{helper_state_dir})
  {
    $conf->{helper_state_dir} = $conf->{default_home_dir};
  }
  
  # If we're in "headers-only" mode, change other settings
  # appropriately.
  
  if ($conf->{headers_only})
  {
    $conf->{use_cli} = 0;
    $conf->{use_user_prefs} = 0;
    $conf->{require_user_prefs} = 0;
    $conf->{use_user_state} = 0;
  }
}


# Return 1 if the passed parameter is one of the various acceptable
# ways of writing "true" (yes, on, 1, etc.), and 0 otherwise.

sub evaluateBoolean 
{
  my $boolean = shift;
  
  if (($boolean =~ /true/i) || ($boolean =~ /yes/i) ||
    ($boolean =~ /on/i) || ($boolean eq "1")) 
  {
    return 1;
  }
  else
  {
    return 0;
  }
}


# Lock standard output (using a lock file).

sub lockStandardOutput
{
  if ($conf->{parallel_requests})
  {
    sysopen(FH, $lock_pathname, O_WRONLY | O_CREAT);
    flock(FH, LOCK_EX);
  }
}

# Unlock standard output (using a lock file). Must be called after 
# lockStandardOutput.

sub unlockStandardOutput
{
  if ($conf->{parallel_requests})
  {
    close(FH);
  }
}


# Generate a unique filename (just a filename, not a full path to anywhere).

sub getUniqueFilename 
{
  my $uniquestring = shift;
  our $seqnum;
  my $basetime=time;
  my $rand=int(rand(10000));
  my $uniquename=$seqnum.".".$basetime.$rand.$uniquestring;
  return $uniquename;
}


# Output a result to standard output. Takes two parameters, the 
# result keyword (OK, FAILURE, etc) and the parameter if any (such
# as the headers to add with ADDHEADER). The result keyword must be
# in CommuniGate Pro String Format, the parameter need not be. Because
# the parameter will be quoted, it is inappropriate to send the interface
# version as a parameter.
#
# This routine handles the sequence numbering automatically.

sub printResult
{
  my $result = shift;
  my $param = shift;
  our $seqnum;
  
  lockStandardOutput();
  print("$seqnum $result");
  if ($param)
  {
    print(" \"".to_cgp_string($param)."\"");
  }
  print("\n");
  unlockStandardOutput();
}


# Output a string to standard output, with leading asterisks and 
# sequence number, for the CommuniGate log. It need not be in
# CommuniGate Pro String Format.

sub printExtraInfo
{
  my $info_string = to_cgp_string(shift);
  our $seqnum;
  
  # Wrap the string, if necessary.

  my $output_line = wrap("* $seqnum ", "* $seqnum   ", $info_string);
  lockStandardOutput();
  print($output_line."\n");
  unlockStandardOutput();
}


# Output a debugging string, if appropriate, to standard output. 
# It will appear in the CommuniGate Pro log, if CommuniGate Pro's
# debug level is set appropriately. It need not be in CommuniGate Pro
# string format.

sub debug 
{
  my $debug_level = scalar(shift);
  my $debug_string = shift;
  our $seqnum;
  
  if ($conf->{debug} && $debug_level <= $conf->{debug_level}) 
  {
    printExtraInfo($debug_string);
  }
}


# Output an error string to standard error and, if standard error is
# redirected to a file, to standared output as well; then exit. This
# is used instead of Perl's "die" to report fatal errors in a way such
# that they are guaranteed to appear in the CommuniGate Pro log (if
# CommuniGate Pro's debug level is set appropriately). The string need not 
# be in CommuniGate Pro string format.

sub error_exit
{
  my $error_string = shift;
  my $cgp_error_string = to_cgp_string($error_string);
  
  select STDERR;
  print("* ".scalar localtime()." CGPSA Error: ".$cgp_error_string."\n");
  select STDOUT;
  
  if ($conf->{redirect_stderr})
  {
    # stderr is redirected, so output to stdout as well
    lockStandardOutput();
    print("* CGPSA Error: ".$cgp_error_string."\n");
    unlockStandardOutput();
  }
  exit();
}

# Convert an arbitrary string to CommuniGate Pro string format, and
# return it as a result.

sub to_cgp_string
{
  my $orig_string = shift;
  $orig_string =~ s/\\/\\\\/g;
  $orig_string =~ s/\e/\\e/g;
  $orig_string =~ s/\r/\\r/g;
  $orig_string =~ s/\n/\\n/g;
  $orig_string =~ s/\t/\\t/g;
  $orig_string =~ s/\"/\\"/g;
  return $orig_string;
}
    
  
# End of CGPSA
